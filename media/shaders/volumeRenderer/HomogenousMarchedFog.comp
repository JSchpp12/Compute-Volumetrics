#version 450

const float PI = 3.1415926535897932384626433832795;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct Light_Type
{
    uint point;
    uint directional;
    uint spot;
};

struct Light
{
    vec4 position;
    vec4 direction;

    // properties
    vec4 ambient;
    vec4 diffuse;
    vec4 specular;
    // controls.x = inner cutoff angle
    // controls.y = outer cutoff angle
    vec4 controls;
    // settings.x = enabled
    // settings.y = type
    uvec4 settings;
};

Light_Type createLightTypeStruct()
{
	Light_Type lightChecker = {
		0x0, 
		0x1, 
		0x2
	};
	return(lightChecker);
}

layout(set = 0, binding = 0) uniform GlobalUniformBufferObject
{
    mat4 proj;
    mat4 view;
    mat4 invView;
} globalUbo;

layout(set = 0, binding = 1) uniform GlobalLightInfo{
    int numLights;
} lightInfo; 

layout(set = 0, binding = 2) readonly buffer GlobalLightBuffer{
    Light lights[];
 } lightList;

layout(set = 1, binding = 0) uniform additionalCameraInfo
{
    mat4 invProj;
    vec2 cameraDimensions;
    float aspectRatio;
    float farClipDist;
    float nearClipDist;
    float scale;
}
addCamInfo;
layout(std430, set = 1, binding = 1) buffer PNanoVDBBuffer{
    uint pnanovdb_buf_data[];
};
layout(r32f, set = 1, binding = 2) uniform readonly image2D randomTexture;

layout(set = 2, binding = 0, rgba8) uniform readonly image2D inputSceneColor;
layout(set = 2, binding = 1) uniform sampler2D inputSceneDepth;
layout(set = 2, binding = 2, rgba8) uniform writeonly image2D outputImage;
layout(set = 2, binding = 3) buffer RayDistanceResult
{
    float rayDistData[]; 
};
layout(set = 2, binding = 4) buffer IsRayAtMaxDistance
{
    uint isAtMaxDistance[];
};

layout(set = 3, binding = 0) uniform InstanceModelMatrix
{
    mat4 instanceModelMatrix[1024];
};
layout(set = 3, binding = 1) uniform InstanceInverseModelMatrix
{
    mat4 instanceInverseMatrix[1024];
};
layout(set = 3, binding = 2) uniform aabbInfo
{
    vec4 bounds[2];
}
aabb;

layout(set = 3, binding = 3) uniform FogControllerInfo
{
    float linearFog_nearDistance;
    float linearFog_farDistance;
    float expFog_density;
    float marchedFog_defaultDensity;
    float marchedFog_sigmaAbsorption;
    float marchedFog_sigmaScattering;
    float marchedFog_lightPropertyDirG;
    float marchedFog_stepSizeDist;
    float marchedFog_stepSizeDist_light;
    uint marchedFog_uniform_maxNumSteps;
    uint gridType;
}
fogInfo;

#include "PNanoVDB.h"
#include "ray_helpers.comp"
#include "volume_helpers.comp"

ivec2 getTargetPixelCoords()
{
    return ivec2((gl_LocalInvocationID.x) + ((gl_WorkGroupID.x) * 8),
                 (gl_LocalInvocationID.y) + ((gl_WorkGroupID.y) * 8));
}

float linearizeDepth(const float depth, const float camNearClipDist, const float camFarClipDist)
{
    /* convert depth value back to linear space -- based on proj matrix
    Source: http://www.songho.ca/opengl/gl_projectionmatrix.html
    Source2: https://learnopengl.com/Advanced-OpenGL/Depth-testing
    */
    return (camNearClipDist * camFarClipDist) / (camFarClipDist - depth * (camFarClipDist - camNearClipDist));
}

float applyHenyeyGreensteinPhase(const float cosTheta, const float g)
{
    float denom = 1.0 + g*g - 2.0*g*cosTheta;
    return (1.0 - g*g) / (4.0 * PI * (denom * sqrt(denom)));
}

float sampleRandomTexture(const ivec2 targetPixel, const int offset)
{
    const ivec2 size = imageSize(randomTexture); 
    
    int index = targetPixel.x + targetPixel.y * size.x; 
    index = (index + offset) % (size.x * size.y); 

    if (index < 0)
    {
        index += size.x * size.y; 
    }

    const int x = index % size.x; 
    const int y = index / size.x; //dont care about remainders, simply truncate
    ivec2 coord = ivec2(x, y); 
    return imageLoad(randomTexture, coord).r; 
}

void forwardMarch(const vec3 backgroundColor, const ivec2 targetPixel, const Ray ray,
                  float sigmaAbsorption, float sigmaScattering, const float lightPropertyDir_g,
                  const float stepSize, const uint numSteps, const float cutOffDistance, 
                  const float defaultDensity, inout vec3 resultingColor, 
                  inout float rayDistanceTraveled)
{ 
    const float lightStengthMulti = 13.0;
    rayDistanceTraveled = 0.0; 

    Light_Type lChecker = createLightTypeStruct(); 
    const float sigmaT = sigmaAbsorption + sigmaScattering;

	float transparency = 1.0;
    float t0 = sampleRandomTexture(targetPixel, 0) * stepSize; 

    vec3 resultingRadiance = vec3(0.0);
    for (int i = 0; i < numSteps; i++)
    {
        float rand = sampleRandomTexture(targetPixel, i); 
        const float t = t0 + (i + rand) * stepSize;  
        if (t >= cutOffDistance || transparency < 0.000001)
        {
            break;
        }

		const vec3 pos = ray.origin.xyz + (t * ray.direction.xyz); 
        vec3 lightSums = vec3(0.0);
        for (int j = 0; j < lightInfo.numLights; j++)
        {
            float lValue = 1.0;
            vec3 lDir;

            const bool isPoint = ((lightList.lights[j].settings.y & lChecker.point) != 0);
            const bool isDirectional = ((lightList.lights[j].settings.y & lChecker.directional) != 0);
            vec3 lPos = vec3(0.0);
            
            if (isPoint)
            {
                //attenuate the lValue as point lights have distance
                const vec3 lPos = lightList.lights[j].position.xyz; 
                const vec3 v = lPos - pos; 
                const float dL = length(v); 
                lDir = v / max(dL, 1e-6); 

                lValue = exp(-sigmaT * defaultDensity); 
            }
            else if (isDirectional)
            {
                //can just use the direction from the light itself
                lDir = normalize(lightList.lights[j].direction.xyz);
            }

            const vec3 cDir = normalize(-ray.direction.xyz);
            const float cosTheta = dot(lDir, cDir);
            const float phase = applyHenyeyGreensteinPhase(cosTheta, lightPropertyDir_g); 

            lightSums += (lightList.lights[j].ambient.rgb * lightStengthMulti) * lValue * phase;
        } 

        const float sampleAttenuation = exp(sigmaT * -defaultDensity * stepSize);
        transparency *= sampleAttenuation; 
        resultingRadiance += transparency * lightSums * sigmaScattering * defaultDensity * stepSize;
        rayDistanceTraveled = t;
    }

    resultingColor = backgroundColor * transparency + resultingRadiance;
}

void writeMaxDistanceTraveled(const float d, const uint index)
{
    if (d >= addCamInfo.farClipDist)
    {
        rayDistData[index] = 0;
    }
    else
    {
        rayDistData[index] = d;
    }

}

void writeDistanceStencilInfo(const float d, const uint index)
{
    if (d >= addCamInfo.farClipDist)
    {
        isAtMaxDistance[index] = 1;
    }
    else
    {
        isAtMaxDistance[index] = 0;
    }
}

void writeDistanceInfo(const float d, const ivec2 tPix, const uvec2 cSize)
{
    const uint index = tPix.x + (tPix.y * cSize.x);  
    writeMaxDistanceTraveled(d, index);
    writeDistanceStencilInfo(d, index);
}

void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    uvec2 size = uvec2(addCamInfo.cameraDimensions.xy);
    if (any(greaterThanEqual(gid, size))) return;

    const ivec2 targetPixel = getTargetPixelCoords(); 
    const float volumeUniformScale = extractUniformVolumeScale(instanceModelMatrix[0]);
    
    float targetPixelInputDepth = texelFetch(inputSceneDepth, targetPixel, 0).r;
    const float linearDepth = linearizeDepth(targetPixelInputDepth, addCamInfo.nearClipDist, addCamInfo.farClipDist); 
    const vec3 backgroundColor = imageLoad(inputSceneColor, targetPixel).rgb;

    vec3 viewDirScene = vec3(0.0); 
    vec3 camPos = vec3(0.0);
    getSceneViewInfoForPix(targetPixel, uvec2(addCamInfo.cameraDimensions.x, addCamInfo.cameraDimensions.y), targetPixelInputDepth, camPos, viewDirScene); 
    Ray worldRay = createRay(camPos, viewDirScene);  

    vec3 resultingColor = vec3(0.0, 0.0, 0.0); 
    float rayDistanceTraveled; 
    forwardMarch(backgroundColor, 
        targetPixel,
        worldRay, 
        fogInfo.marchedFog_sigmaAbsorption,
        fogInfo.marchedFog_sigmaScattering,
        fogInfo.marchedFog_lightPropertyDirG, 
        fogInfo.marchedFog_stepSizeDist,
        fogInfo.marchedFog_uniform_maxNumSteps,
        linearDepth,
        fogInfo.marchedFog_defaultDensity,
        resultingColor,
        rayDistanceTraveled
    );

    writeDistanceInfo(rayDistanceTraveled, targetPixel, size); 
    imageStore(outputImage, targetPixel, vec4(resultingColor, 1.0));
}